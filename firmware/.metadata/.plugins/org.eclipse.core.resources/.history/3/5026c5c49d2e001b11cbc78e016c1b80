#include "as5048a.hh"

#define ADDR_NOP 					0x0000
#define ADDR_CLEAR_ERROR_FLAG 		0X0001
#define ADDR_PROG_CONTROL			0x0003
#define ADDR_OTP_REG_ZERO_POS_HI	0x0016 // high byte
#define ADDR_OTP_REG_ZERO_POS_LOW	0x0017 // lower 6 LSBs
#define ADDR_DIAG_AGC				0x3FFD
#define ADDR_MAG					0x3FFE
#define ADDR_ANGLE					0x3FFF

/**
 * @brief Constructor.
 */
AS5048A::AS5048A(SPI_HandleTypeDef * encoder_spi) {
	encoder_spi_ = encoder_spi;
}

/**
 * @brief Initializes the interface to the AS5048A
 */
void AS5048A::Init() {

}

/**
 * @brief Reads the AS5048A encoder over SPI.
 */
void AS5048A::Update() {

}

/**
 * @brief Calculates the parity bit to ensure that a 16-bit unsigned integer has even parity.
 * @param[in] val 16-bit value that needs a parity bit (only the 15 LS bits are read).
 * @retval The parity bit that will reside in the MS bit to make the uint16_t have even parity.
 */
uint8_t AS5048A::CalcEvenParity_(uint16_t val) {
	uint8_t par = 0;
	for (uint8_t shift = 0; shift < 15; shift++) {
		par ^= ((val >> shift) & 0x1);
	}
	return par;
}

/**
 * @brief Creates a data packet for specifying an AS5048A address.
 * @param[in] addr 14 bit address code.
 * @param[in] rw 1-bit read(1)/write(0) flag.
 * @retval 16-bit command packet.
 */
uint16_t AS5048A::CreateCommandPacket_(uint16_t addr, uint8_t rw) {
	uint16_t pack = addr & (0xFFFF >> 2); // ignore 2 MSbs
	pack |= (rw & 0b1) << 14; // mask r/w bit, set as bit 15
	pack |= CalcEvenParity_(pack) << 15; // set parity bit
	return pack;
}

/**
 * @brief Creates a data packet that can be written to a previously specified AS5048A address.
 * @param[in] data 14 bit data to write to the selected address.
 * @retval 16-bit write packet with parity bit and reserved bit populated.
 */
uint16_t AS5048A::CreateWritePacket_(uint16_t data) {
	return 0;
}

uint16_t AS5048A::ParseReadPacket_(uint16_t packet) {
	return 0;
}
