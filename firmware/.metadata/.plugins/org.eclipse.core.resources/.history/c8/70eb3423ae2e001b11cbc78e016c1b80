#include "as5048a.hh"

#define ADDR_NOP 					0x0000
#define ADDR_CLEAR_ERROR_FLAG 		0X0001
#define ADDR_PROG_CONTROL			0x0003
#define ADDR_OTP_REG_ZERO_POS_HI	0x0016 // high byte
#define ADDR_OTP_REG_ZERO_POS_LOW	0x0017 // lower 6 LSBs
#define ADDR_DIAG_AGC				0x3FFD
#define ADDR_MAG					0x3FFE
#define ADDR_ANGLE					0x3FFF

#define CMD_WRITE					0x0
#define CMD_READ					0X1

#define DATA_DUMMY					0x0000

#define PARSE_ERR					0xFFFF // for internal use when an invalid packet is parsed

/**
 * @brief Constructor.
 */
AS5048A::AS5048A(SPI_HandleTypeDef * encoder_spi, uint32_t spi_timeout)
	: encoder_spi_(encoder_spi)
	, spi_timeout_(spi_timeout)
{

}

/**
 * @brief Initializes the interface to the AS5048A
 */
void AS5048A::Init() {

}

/**
 * @brief Reads the AS5048A encoder over SPI.
 */
void AS5048A::Update() {

}

/**
 * @brief Calculates the parity bit to ensure that a 16-bit unsigned integer has even parity.
 * @param[in] val 16-bit value that needs a parity bit (only the 15 LS bits are read).
 * @retval The parity bit that will reside in the MS bit to make the uint16_t have even parity.
 */
uint8_t AS5048A::CalcEvenParity_(uint16_t val) {
	uint8_t par = 0;
	for (uint8_t shift = 0; shift < 15; shift++) {
		par ^= ((val >> shift) & 0x1);
	}
	return par;
}

/**
 * @brief Creates a data packet for specifying an AS5048A address.
 * @param[in] addr 14 bit address code.
 * @param[in] rw 1-bit read(1)/write(0) flag.
 * @retval 16-bit command packet.
 */
uint16_t AS5048A::CreateCommandPacket_(uint16_t addr, uint8_t rw) {
	uint16_t pack = addr & (0xFFFF >> 2); // ignore 2 MSbs
	pack |= (rw & 0b1) << 14; // mask r/w bit, set as bit 15
	pack |= CalcEvenParity_(pack) << 15; // set parity bit
	return pack;
}

/**
 * @brief Creates a data packet that can be written to a previously specified AS5048A address.
 * @param[in] data 14 bit data to write to the selected address.
 * @retval 16-bit write packet with parity bit and reserved bit populated.
 */
uint16_t AS5048A::CreateWritePacket_(uint16_t data) {
	uint16_t pack = data & (0xFFFF >> 2); // ignore 2 MSBs
	// bit 14 has to be 0 (already done)
	pack |= CalcEvenParity_(pack) << 15; // set parity bit
	return pack;
}

/**
 * @brief Extracts data from a packet received from the AS5048A. Can indicate a parity error with PARSE_ERR.
 * @param[in] packet Raw SPI packet received from AS5048a.
 * @retval Extracted data if parse successful, otherwise PARSE_ERR.
 */
uint16_t AS5048A::ParseReceivedPacket_(uint16_t packet) {
	if ((packet >> 14) & 0x1) {
		// EF error flag is set, issue with previous host transmission
		return PARSE_ERR;
	}
	if (CalcEvenParity_(packet) != (packet >> 15)) {
		// parity bit is incorrect
		return PARSE_ERR;
	}
	return (packet & (0xFFFF >> 2));
}

uint16_t AS5048A::ReadAngle_() {
//	uint8_t tx_buf[4];
//	uint8_t rx_buf[2];
	uint16_t read_cmd = CreateCommandPacket_(ADDR_ANGLE, CMD_READ);
	HAL_SPI_Transmit(encoder_spi_, (uint8_t *)&read_cmd, 2, spi_timeout_);

	uint16_t dummy_data = CreateWritePacket_(DATA_DUMMY);
	uint16_t rx_buf;
	HAL_SPI_TransmitReceive(encoder_spi_, (uint8_t *)&dummy_data, (uint8_t *)&rx_buf, spi_timeout_);

	return ParseReceivedPacket(rx_buf);
//	tx_buf[0] = read_cmd & 0xFF; // LSB of read_cmd
//	tx_buf[1] = read_cmd >> 8; // MSB of read_cmd

//	tx_buf[2] = dummy_data & 0xFF; // 8 LSB of dummy_data
//	tx_buf[3] = dummy_data >> 8; // MSB of dummy_data
//	HAL_SPI_TransmitReceive(hspi, &tx_buf, &rx_buf, 4, Timeout)
}
